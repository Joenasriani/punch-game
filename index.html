<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRESS BUSTER 3000</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #ffffff;
            color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
        }

        .title-font {
            font-family: 'Anton', 'Impact', 'Arial Black', sans-serif;
            letter-spacing: 0.12em;
        }

        @keyframes highlight-intro {
            0% { transform: scale(1); border-color: #e5e7eb; }
            50% { transform: scale(1.25); border-color: #6366f1; box-shadow: 0 0 20px rgba(99, 102, 241, 0.4); z-index: 30; }
            100% { transform: scale(1); border-color: #e5e7eb; }
        }

        .intro-highlight {
            animation: highlight-intro 0.6s ease-out forwards;
        }

        /* Target the container for shaking so the fixed cursor stays still */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        
        .shake-active {
            animation: shake 0.15s;
            animation-iteration-count: 1;
        }

        #game-wrapper {
            position: relative;
            max-width: 95vw;
            margin: 20px auto;
            display: none;
            cursor: none;
        }
        canvas {
            border: 4px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
            background-color: #f3f4f6;
            image-rendering: auto;
        }
        .fist-cursor {
            position: fixed;
            width: 120px;
            height: 120px;
            pointer-events: none;
            z-index: 1000;
            font-size: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.05s ease-out;
            filter: drop-shadow(0 10px 15px rgba(0,0,0,0.2));
            transform-origin: center center;
            line-height: 1;
        }
        /* Strictly scaling only to prevent drift */
        .punching {
            transform: scale(1.25);
        }
        #library {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            width: 100%;
            max-width: 1200px;
            padding: 25px;
            margin-bottom: 1.5rem;
            justify-content: center;
        }
        .thumb-btn {
            flex: 0 0 auto;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #e5e7eb;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
            background: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px;
            position: relative;
        }
        .thumb-btn:hover {
            border-color: #6366f1;
            transform: scale(1.15) !important;
            z-index: 20;
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.25);
        }
        .thumb-btn img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        #loading-indicator {
            display: none;
            color: #6366f1;
            font-weight: bold;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>

    <!-- Main Container for UI and Game (This will shake) -->
    <div id="shake-container" class="flex flex-col items-center py-20 px-4 min-h-screen w-full">
        <div class="text-center mb-10">
            <div class="text-6xl font-black mb-5 text-indigo-600 uppercase title-font pl-[0.12em]">STRESS BUSTER 3000</div>
            <p class="text-indigo-400 text-[10px] font-bold uppercase tracking-[0.5em] pl-[0.5em]">release your temper!</p>
        </div>

        <div id="library">
            <!-- Populated by JS -->
        </div>

        <div id="loading-indicator">PREPARING TARGET...</div>

        <div id="setup-screen" class="w-full max-w-md mb-8 text-center">
            <label class="flex flex-col items-center justify-center w-full h-16 cursor-pointer rounded-xl border-2 border-dashed border-gray-300 hover:bg-gray-100 transition">
                <p class="text-sm text-gray-500 font-semibold">or Upload Custom Victim</p>
                <input id="image-input" type="file" class="hidden" accept="image/*" />
            </label>
            <p class="text-xs text-indigo-400 mt-2 font-medium italic">High-resolution images work best.</p>
        </div>

        <div id="game-wrapper">
            <canvas id="game-canvas"></canvas>
        </div>

        <div id="controls" class="hidden mt-12 mb-20 flex flex-wrap justify-center gap-6">
            <button id="reset-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-10 py-3 rounded-full font-bold transition">Reset Face</button>
            <button id="save-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-10 py-3 rounded-full font-bold transition">Save Result</button>
        </div>
    </div>

    <!-- Punch Icon outside the shake container to remain perfectly still -->
    <div id="custom-cursor" class="fist-cursor hidden">ðŸ‘Š</div>

    <script>
        const imageInput = document.getElementById('image-input');
        const setupScreen = document.getElementById('setup-screen');
        const gameWrapper = document.getElementById('game-wrapper');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });

        const controls = document.getElementById('controls');
        const customCursor = document.getElementById('custom-cursor');
        const saveBtn = document.getElementById('save-btn');
        const resetBtn = document.getElementById('reset-btn');
        const libraryDiv = document.getElementById('library');
        const loadingIndicator = document.getElementById('loading-indicator');
        const shakeContainer = document.getElementById('shake-container');

        const PEOPLE = [
            { name: "TRUMP", url: "/img/trump.jpg" },
            { name: "BEZOS", url: "/img/bezos.jpg" },
            { name: "ELON", url: "/img/elon.jpeg" },
            { name: "ZUCKERBERG", url: "/img/zuckerberg.jpg" },
            { name: "GATES", url: "/img/gates.jpg" },
            { name: "COOK", url: "/img/cook.jpg" },
            { name: "ALTMAN", url: "/img/altman.jpg" }
        ];

        let currentImgUrl = PEOPLE[0].url;
        let particles = [];
        let animationFrame;
        let audioCtx;

        function playPunchSFX() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;

            const osc = audioCtx.createOscillator();
            const gThump = audioCtx.createGain();
            const lowFilter = audioCtx.createBiquadFilter();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            lowFilter.type = 'lowpass';
            lowFilter.frequency.setValueAtTime(400, now);
            gThump.gain.setValueAtTime(0.6, now);
            gThump.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.connect(lowFilter);
            lowFilter.connect(gThump);
            gThump.connect(audioCtx.destination);
            osc.start();
            osc.stop(now + 0.15);

            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            const gTesh = audioCtx.createGain();
            const highFilter = audioCtx.createBiquadFilter();
            highFilter.type = 'highpass';
            highFilter.frequency.setValueAtTime(2500, now);
            gTesh.gain.setValueAtTime(0.3, now);
            gTesh.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            noiseSource.connect(highFilter);
            highFilter.connect(gTesh);
            gTesh.connect(audioCtx.destination);
            noiseSource.start();
            noiseSource.stop(now + 0.1);
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * 14;
                this.speedY = (Math.random() - 0.5) * 14 - 5;
                this.gravity = 0.5;
                this.r = 190 + Math.random() * 65;
                this.g = Math.random() * 10;
                this.b = Math.random() * 10;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
            }
            draw() {
                ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function spawnBlood(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y));
            }
            if (!animationFrame) loop();
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offCanvas, 0, 0);

            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            if (particles.length > 0) {
                animationFrame = requestAnimationFrame(loop);
            } else {
                animationFrame = null;
                ctx.drawImage(offCanvas, 0, 0);
            }
        }

        function populateLibrary() {
            libraryDiv.innerHTML = '';
            PEOPLE.forEach((person, index) => {
                const btn = document.createElement('div');
                btn.className = 'thumb-btn';
                btn.title = person.name;
                
                btn.classList.add('intro-highlight');
                btn.style.animationDelay = `${index * 0.1}s`;

                const img = document.createElement('img');
                img.src = person.url;
                img.alt = person.name;
                img.onerror = () => {
                    img.style.display = 'none';
                    const span = document.createElement('span');
                    span.className = 'text-[10px] font-bold text-gray-400 uppercase tracking-tighter';
                    span.innerText = person.name;
                    btn.appendChild(span);
                };

                btn.appendChild(img);
                btn.onclick = () => {
                    currentImgUrl = person.url;
                    initGameWithImage(person.url);
                };
                libraryDiv.appendChild(btn);
            });
        }

        function initGameWithImage(imgSrc) {
            loadingIndicator.style.display = 'block';
            gameWrapper.style.display = 'none';
            controls.classList.add('hidden');

            const img = new Image();
            img.onload = function() {
                loadingIndicator.style.display = 'none';
                const maxW = window.innerWidth * 0.95;
                const maxH = window.innerHeight * 0.65;
                let scale = Math.min(maxW / img.width, maxH / img.height);
                
                canvas.width = offCanvas.width = img.width * scale;
                canvas.height = offCanvas.height = img.height * scale;
                
                offCtx.imageSmoothingEnabled = true;
                offCtx.imageSmoothingQuality = 'high';
                offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
                offCtx.drawImage(img, 0, 0, offCanvas.width, offCanvas.height);
                
                ctx.drawImage(offCanvas, 0, 0);
                
                gameWrapper.style.display = 'block';
                controls.classList.remove('hidden');
                customCursor.classList.remove('hidden');
            };
            img.onerror = () => {
                loadingIndicator.style.display = 'none';
                console.warn("Local image not found at: " + imgSrc);
            };
            img.src = imgSrc;
        }

        window.onload = () => {
            populateLibrary();
            initGameWithImage(currentImgUrl);
        };

        resetBtn.onclick = () => initGameWithImage(currentImgUrl);

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                currentImgUrl = event.target.result;
                initGameWithImage(currentImgUrl);
            };
            reader.readAsDataURL(file);
        });

        window.addEventListener('mousemove', (e) => {
            customCursor.style.left = (e.clientX - 60) + 'px';
            customCursor.style.top = (e.clientY - 60) + 'px';
        });

        saveBtn.onclick = () => {
            const link = document.createElement('a');
            link.download = 'punched-result.png';
            link.href = offCanvas.toDataURL('image/png');
            link.click();
        };

        function applySubtleSmudge(cx, cy) {
            const radius = 95;
            const strength = 0.22; 
            
            const startX = Math.max(0, Math.floor(cx - radius));
            const startY = Math.max(0, Math.floor(cy - radius));
            const endX = Math.min(offCanvas.width, Math.ceil(cx + radius));
            const endY = Math.min(offCanvas.height, Math.ceil(cy + radius));
            const width = endX - startX;
            const height = endY - startY;

            if (width <= 0 || height <= 0) return;

            const imageData = offCtx.getImageData(startX, startY, width, height);
            const data = imageData.data;
            const copy = new Uint8ClampedArray(data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dx = (startX + x) - cx;
                    const dy = (startY + y) - cy;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        const normDist = distance / radius;
                        const factor = (1 - normDist) * strength;
                        const srcX = (startX + x) - (dx * factor);
                        const srcY = (startY + y) - (dy * factor);
                        
                        const sx = Math.floor(Math.max(0, Math.min(width + startX - 1, srcX))) - startX;
                        const sy = Math.floor(Math.max(0, Math.min(height + startY - 1, srcY))) - startY;
                        
                        const si = (sy * width + sx) * 4;
                        const di = (y * width + x) * 4;
                        
                        data[di] = copy[si];
                        data[di+1] = copy[si+1];
                        data[di+2] = copy[si+2];
                        data[di+3] = copy[si+3];
                    }
                }
            }
            offCtx.putImageData(imageData, startX, startY);

            const grad = offCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            grad.addColorStop(0, 'rgba(0, 0, 0, 0.04)');
            grad.addColorStop(0.7, 'rgba(0, 0, 0, 0.01)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            offCtx.fillStyle = grad;
            offCtx.beginPath();
            offCtx.arc(cx, cy, radius, 0, Math.PI * 2);
            offCtx.fill();
        }

        function handlePunch(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (clientY - rect.top) * (canvas.height / rect.height);
            
            if (canvasX < 0 || canvasX > canvas.width || canvasY < 0 || canvasY > canvas.height) return;
            
            customCursor.classList.add('punching');
            setTimeout(() => customCursor.classList.remove('punching'), 100);
            
            playPunchSFX();
            
            applySubtleSmudge(canvasX, canvasY);
            spawnBlood(canvasX, canvasY);
            
            shakeContainer.classList.remove('shake-active');
            void shakeContainer.offsetWidth; 
            shakeContainer.classList.add('shake-active');
        }

        canvas.addEventListener('mousedown', (e) => handlePunch(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handlePunch(touch.clientX, touch.clientY);
        }, { passive: false });
    </script>
</body>
</html>
